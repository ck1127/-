server.port=12000
spring.application.name=consumer-server
eureka.client.service-url.defaultZone=http://localhost:13000/eureka,http://localhost:13001/eureka
eureka.instance.prefer-ip-address=true
eureka.instance.instance-id=${spring.cloud.client.ip-address}:${server.port}
eureka.instance.lease-renewal-interval-in-seconds=5
eureka.instance.lease-expiration-duration-in-seconds=30


#
##失败请求百分比，超过这个比例，熔断(circuitbreaker)打开
#resilience4j.circuitbreaker.configs.default.failure-rate-threshold=30
##滑动窗口的类型，TIME_BASED，COUNT_BASED
#resilience4j.circuitbreaker.configs.default.sliding-window-type=TIME_BASED
##滑动窗口的大小，对于配置COUNT_BASED表示10个请求，对于配置TIME_BASED表示10秒。设置的越短，触发的频率越高，程序越安全,但消耗的资源越多
#resilience4j.circuitbreaker.configs.default.sliding-window-size=10
##最小请求个数，只有滑动窗口内，请求的个数达到这个数量才会触发circuitbreaker对于断路器的判断
#resilience4j.circuitbreaker.configs.default.minimum-number-of-calls=2
##设置true，表示自动从OPEN状态到HALFOPEN状态，即使没有请求过来
#resilience4j.circuitbreaker.configs.default.automatic-transition-from-open-to-half-open-enabled=true
##from-open-to-half-open的时间
#resilience4j.circuitbreaker.configs.default.wait-duration-in-open-state=2s
#resilience4j.circuitbreaker.configs.default.permitted-number-of-calls-in-half-open-state=3
##白名单  resilience4j.circuitbreaker.configs.default.ignore-exceptions[0]=
##黑名单
#resilience4j.circuitbreaker.configs.default.record-exceptions[0]=java.lang.Exception
#
#
##构造熔断器backendA实例
#resilience4j.circuitbreaker.instances.backendA.base-config=default
##构造熔断器backendB实例
#resilience4j.circuitbreaker.instances.backendB.failure-rate-threshold=50
#resilience4j.circuitbreaker.instances.backendB.sliding-window-type=TIME_BASED
#resilience4j.circuitbreaker.instances.backendB.sliding-window-size=10
##慢调用百分比阈值
#resilience4j.circuitbreaker.instances.backendB.slow-call-rate-threshold=30
##慢调用时间阈值，高于这个时间的请求视为慢调用
#resilience4j.circuitbreaker.instances.backendB.slow-call-duration-threshold=2s
#resilience4j.circuitbreaker.instances.backendB.minimum-number-of-calls=2
#resilience4j.circuitbreaker.instances.backendB.permitted-number-of-calls-in-half-open-state=3
##from-open-to-half-open的时间
#resilience4j.circuitbreaker.instances.backendB.wait-duration-in-open-state=2s



##熔断与隔离不一样，隔离是主动设置的，熔断是遇到特殊情况遇到问题（失效和慢调用）后被动执行的
##表示隔离，允许并发执行的最大数目
#resilience4j.bulkhead.configs.default.max-concurrent-calls=5
##达到最大数目的时候，如果有新的进程到来需要等待20ms，阻塞时间
#resilience4j.bulkhead.configs.default.max-wait-duration=20ms
#resilience4j.bulkhead.instances.bulkheadA.base-config=default
#resilience4j.bulkhead.instances.bulkheadB.max-concurrent-calls=10
#resilience4j.bulkhead.instances.bulkheadB.max-wait-duration=5ms



##最大线程池的大小
#resilience4j.thread-pool-bulkhead.configs.default.max-thread-pool-size=5
##核心线程池大小
#resilience4j.thread-pool-bulkhead.configs.default.core-thread-pool-size=3
##队列容量
#resilience4j.thread-pool-bulkhead.configs.default.queue-capacity=5
###多余空线程在终止前等待新任务的最长时间
##resilience4j.thread-pool-bulkhead.configs.default.keep-alive-duration=20ms
#resilience4j.thread-pool-bulkhead.instances.bulkheadA.base-config=default



#在一个刷新周期内，允许执行的最大请求数
resilience4j.ratelimiter.configs.default.limit-for-period=5
#限流器每隔一秒刷新一次，将允许处理的最大请求重置为5
resilience4j.ratelimiter.configs.default.limit-refresh-period=1s
#线程默认等待时间
resilience4j.ratelimiter.configs.default.timeout-duration=5s
#新建限流实例
resilience4j.ratelimiter.instances.ratelimiterA.base-config=default
resilience4j.ratelimiter.instances.ratelimiterB.limit-for-period=2
resilience4j.ratelimiter.instances.ratelimiterB.limit-refresh-period=1s
resilience4j.ratelimiter.instances.ratelimiterB.timeout-duration=10s
#熔断是必须有的，防止雪崩。限流、隔离是用于抢票秒杀活动
